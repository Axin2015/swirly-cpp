#!/usr/bin/env python

from contextlib import contextmanager
from dbrpy import *
from threading import Thread
from uuid import *

import os, shlex, sys

TMOUT = 5000

ACTIONS = {
    ACTION_BUY: 'BUY',
    ACTION_SELL: 'SELL'
}

ROLES = {
    ROLE_MAKER: 'MAKER',
    ROLE_TAKER: 'TAKER'
}

STATES = {
    STATE_NEW: 'NEW',
    STATE_REVISE: 'REVISE',
    STATE_CANCEL: 'CANCEL',
    STATE_TRADE: 'TRADE'
}

def iso_to_jd(iso):
    return ymd_to_jd(*iso_to_ymd(int(iso)))

def jd_to_iso(jd):
    return ymd_to_iso(*jd_to_ymd(jd))

def get_arec_id(clnt, id):
    arec = clnt.find_rec_id(ENTITY_ACCNT, id)
    if not arec:
        err_set(EINVAL, "no such account '{0}'".format(id))
        raise Error()
    return arec

def get_arec_mnem(clnt, mnem):
    arec = clnt.find_rec_mnem(ENTITY_ACCNT, mnem)
    if not arec:
        err_set(EINVAL, "no such account '{0}'".format(mnem))
        raise Error()
    return arec

def get_crec_id(clnt, id):
    crec = clnt.find_rec_id(ENTITY_CONTR, id)
    if not crec:
        err_set(EINVAL, "no such contract '{0}'".format(id))
        raise Error()
    return crec

def get_crec_mnem(clnt, mnem):
    crec = clnt.find_rec_mnem(ENTITY_CONTR, mnem)
    if not crec:
        err_set(EINVAL, "no such contract '{0}'".format(mnem))
        raise Error()
    return crec

def prompt():
    sys.stdout.write('> ')
    sys.stdout.flush()

def parse(lex, obj):
    toks = []
    prompt()
    while not obj.is_closed:
        tok = lex.get_token()
        if tok == lex.eof:
            log_info('end-of-file')
            break
        if tok == ';':
            if len(toks) > 0:
                try:
                    fn = getattr(obj, toks[0])
                    fn(*toks[1:])
                except Exception as e:
                    log_error('error: ' + str(e))
                toks = []
            prompt()
        else:
            toks.append(tok)

class RequestHandler(Handler):
    def __init__(self, clnt):
        super(RequestHandler, self).__init__()
        self.clnt = clnt

    def on_close(self):
        log_notice('on_close')

    def on_ready(self):
        log_notice('on_ready')

    def on_logon(self, req_id, uid):
        log_notice('on_logon: {0}: {1}'.format(req_id, uid))

    def on_logoff(self, req_id, uid):
        log_notice('on_logoff: {0}: {1}'.format(req_id, uid))

    def on_reset(self):
        log_notice('on_reset')

    def on_timeout(self, req_id):
        log_notice('on_timeout: {0}'.format(req_id))

    def on_status(self, req_id, num, msg):
        log_notice('on_status: {0}: {2} ({1})'.format(req_id, num, msg))

    def on_exec(self, req_id, exc):
        log_notice('on_exec: {0}: {1}'.format(req_id, exc))

    def on_posn(self, posn):
        log_notice('on_posn: {0}'.format(posn))

    def on_view(self, view):
        log_notice('on_view: {0}'.format(view))

    def on_flush(self):
        pass

    def on_async(self, fn):
        ret = None
        try:
            ret = fn(self.clnt)
        except Exception as e:
            ret = e
        return ret

def worker(ctx, uuid):
    log_setlevel(3)
    pool = Pool(8 * 1024 * 1024)
    clnt = Clnt(ctx, uuid, 'tcp://localhost:3270', 'tcp://localhost:3271',
                millis(), TMOUT, pool)
    handler = RequestHandler(clnt)
    while True:
        try:
            if not clnt.dispatch(TMOUT, handler):
                break
        except Error as e:
            log_error('error: ' + str(e))

class CloseRequest(object):
    def __call__(self, clnt):
        return clnt.close()

class AccntsRequest(object):
    @staticmethod
    def to_dict(clnt, arec):
        return {
            'id': arec.id,
            'mnem': arec.mnem,
            'display': arec.display,
            'email': arec.email
        }
    def __init__(self, *mnems):
        self.mnems = set(mnems)
    def __call__(self, clnt):
        accnts = []
        if self.mnems:
            for mnem in self.mnems:
                arec = get_arec_mnem(clnt, mnem)
                accnts.append(AccntsRequest.to_dict(clnt, arec))
        else:
            accnts = [AccntsRequest.to_dict(clnt, arec)
                      for arec in clnt.list_rec(ENTITY_ACCNT)]
        return accnts

class ContrsRequest(object):
    @staticmethod
    def to_dict(clnt, crec):
        return {
            'id': crec.id,
            'mnem': crec.mnem,
            'display': crec.display,
            'asset_type': crec.asset_type,
            'asset': crec.asset,
            'ccy': crec.ccy,
            'tick_numer': crec.tick_numer,
            'tick_denom': crec.tick_denom,
            'lot_numer': crec.lot_numer,
            'lot_denom': crec.lot_denom,
            'price_dp': crec.price_dp,
            'pip_dp': crec.pip_dp,
            'qty_dp': crec.qty_dp,
            'min_lots': crec.min_lots,
            'max_lots': crec.max_lots
        }
    def __init__(self, *mnems):
        self.mnems = set(mnems)
    def __call__(self, clnt):
        contrs = []
        if self.mnems:
            for mnem in self.mnems:
                crec = get_crec_mnem(clnt, mnem)
                contrs.append(ContrsRequest.to_dict(clnt, crec))
        else:
            contrs = [ContrsRequest.to_dict(clnt, crec)
                      for crec in clnt.list_rec(ENTITY_CONTR)]
        return contrs

class LogonRequest(object):
    def __init__(self, umnem):
        self.umnem = umnem
    def __call__(self, clnt):
        urec = get_arec_mnem(clnt, self.umnem)
        return clnt.logon(clnt.accnt(urec))

class LogoffRequest(object):
    def __init__(self, umnem):
        self.umnem = umnem
    def __call__(self, clnt):
        urec = get_arec_mnem(clnt, self.umnem)
        return clnt.logoff(clnt.accnt(urec))

class UsersRequest(object):
    @staticmethod
    def to_dict(clnt, memb):
        return {
            'uid': memb.uid,
            'gid': memb.gid
        }
    def __init__(self, umnem):
        self.umnem = umnem
    def __call__(self, clnt):
        membs = []
        urec = get_arec_mnem(clnt, self.umnem)
        user = clnt.accnt(urec)
        membs = [UsersRequest.to_dict(clnt, memb)
                 for memb in user.list_user()]
        return membs

class GroupsRequest(object):
    @staticmethod
    def to_dict(clnt, memb):
        return {
            'uid': memb.uid,
            'gid': memb.gid
        }
    def __init__(self, umnem):
        self.umnem = umnem
    def __call__(self, clnt):
        membs = []
        urec = get_arec_mnem(clnt, self.umnem)
        user = clnt.accnt(urec)
        membs = [GroupsRequest.to_dict(clnt, memb)
                 for memb in user.list_group()]
        return membs

class OrdersRequest(object):
    @staticmethod
    def to_dict(clnt, order):
        urec = get_arec_id(clnt, order.uid)
        grec = get_arec_id(clnt, order.gid)
        crec = get_crec_id(clnt, order.cid)
        return {
            'id': order.id,
            'umnem': urec.mnem,
            'gmnem': grec.mnem,
            'cmnem': crec.mnem,
            'settl_date': jd_to_iso(order.settl_day),
            'ref': order.ref,
            'state': STATES[order.state],
            'action': ACTIONS[order.action],
            'price': crec.ticks_to_price(order.ticks),
            'lots': order.lots,
            'resd': order.resd,
            'exc': order.exc,
            'last_price': crec.ticks_to_price(order.last_ticks),
            'last_lots': order.last_lots,
            'min_lots': order.min_lots,
            'created': order.created,
            'modified': order.modified
        }
    def __init__(self, umnem):
        self.umnem = umnem
    def __call__(self, clnt):
        orders = []
        urec = get_arec_mnem(clnt, self.umnem)
        user = clnt.accnt(urec)
        orders = [OrdersRequest.to_dict(clnt, order)
                  for order in user.list_order()]
        return orders

class TradesRequest(object):
    @staticmethod
    def to_dict(clnt, exc):
        urec = get_arec_id(clnt, exc.uid)
        grec = get_arec_id(clnt, exc.gid)
        crec = get_crec_id(clnt, exc.cid)
        return {
            'id': exc.id,
            'order': exc.order,
            'umnem': urec.mnem,
            'gmnem': grec.mnem,
            'cmnem': crec.mnem,
            'settl_date': jd_to_iso(exc.settl_day),
            'ref': exc.ref,
            'state': STATES[exc.state],
            'action': ACTIONS[exc.action],
            'price': crec.ticks_to_price(exc.ticks),
            'lots': exc.lots,
            'resd': exc.resd,
            'exc': exc.exc,
            'last_price': crec.ticks_to_price(exc.last_ticks),
            'last_lots': exc.last_lots,
            'min_lots': exc.min_lots,
            'match': exc.match,
            'role':  ROLES[exc.role] if exc.state == STATE_TRADE else None,
            'cpty': get_arec_id(clnt, exc.gid).mnem if exc.state == STATE_TRADE else None,
            'created': exc.created
        }
    def __init__(self, umnem):
        self.umnem = umnem
    def __call__(self, clnt):
        trades = []
        urec = get_arec_mnem(clnt, self.umnem)
        user = clnt.accnt(urec)
        trades = [TradesRequest.to_dict(clnt, exc)
                  for exc in user.list_trade()]
        return trades

class PosnsRequest(object):
    @staticmethod
    def to_dict(clnt, posn):
        grec = get_arec_id(clnt, posn.gid)
        crec = get_crec_id(clnt, posn.cid)
        buy_ticks = float(posn.buy_licks) / posn.buy_lots
        sell_ticks = float(posn.sell_licks) / posn.sell_lots
        return {
            'gnnem': grec.mnem,
            'cmnem': crec.mnem,
            'settl_date': jd_to_iso(posn.settl_day),
            'buy_price': buy_ticks * crec.price_inc,
            'buy_lots': posn.buy_lots,
            'sell_price': sell_ticks * crec.price_inc,
            'sell_lots': posn.sell_lots
        }
    def __init__(self, gmnem):
        self.gmnem = gmnem
    def __call__(self, clnt):
        posns = []
        grec = get_arec_mnem(clnt, self.gmnem)
        group = clnt.accnt(grec)
        posns = [PosnsRequest.to_dict(clnt, posn)
                 for posn in group.list_posn()]
        return posns

class LevelsRequest(object):
    @staticmethod
    def to_dict(clnt, view,  i):
        crec = get_crec_id(clnt, view.cid)
        return {
            'cmnem': crec.mnem,
            'settl_date': jd_to_iso(view.settl_day),
            'level': i + 1,
            'bid_price': crec.ticks_to_price(view.list_bid[i].ticks),
            'bid_lots': view.list_bid[i].lots,
            'bid_count': view.list_bid[i].count,
            'offer_price': crec.ticks_to_price(view.list_offer[i].ticks),
            'offer_lots': view.list_offer[i].lots,
            'offer_count': view.list_offer[i].count
        }
    def __init__(self, cmnem, settl_date):
        self.cmnem = cmnem
        self.settl_day = iso_to_jd(settl_date)
    def __call__(self, clnt):
        levels = []
        crec = get_crec_mnem(clnt, self.cmnem)
        view = clnt.find_view(crec.id, self.settl_day)
        if view:
            for i in range(3):
                levels.append(LevelsRequest.to_dict(clnt, view, i))
        return levels

class ViewsRequest(object):
    @staticmethod
    def to_dict(clnt, view,  i):
        crec = get_crec_id(clnt, view.cid)
        return {
            'cmnem': crec.mnem,
            'settl_date': jd_to_iso(view.settl_day),
            'level': i + 1,
            'bid_price': crec.ticks_to_price(view.list_bid[i].ticks),
            'bid_lots': view.list_bid[i].lots,
            'bid_count': view.list_bid[i].count,
            'offer_price': crec.ticks_to_price(view.list_offer[i].ticks),
            'offer_lots': view.list_offer[i].lots,
            'offer_count': view.list_offer[i].count
        }
    def __init__(self, cmnems, settl_dates):
        self.cmnems = set(cmnems)
        self.settl_days = {iso_to_jd(x) for x in settl_dates}
    def __call__(self, clnt):
        cids = set()
        for cmnem in self.cmnems:
            crec = get_crec_mnem(clnt, cmnem)
            cids.add(crec.id)
        views = []
        if cids:
            if self.settl_days:
                # Cids and settl_days.
                for cid in cids:
                    for settl_day in self.settl_days:
                        view = clnt.find_view(crec.id, settl_day)
                        if view:
                            views.append(ViewsRequest.to_dict(clnt, view, 0))
            else:
                # Cids only.
                views = [ViewsRequest.to_dict(clnt, view, 0) for view in clnt.list_view()
                         if view.cid in cids]
        else:
            if self.settl_days:
                # Settl_days only.
                views = [ViewsRequest.to_dict(clnt, view, 0) for view in clnt.list_view()
                         if view.settl_day in self.settl_days]
            else:
                # Neither cids nor settl_days.
                views = [ViewsRequest.to_dict(clnt, view, 0) for view in clnt.list_view()]
        return views

class PlaceRequest(object):
    def __init__(self, umnem, gmnem, cmnem, settl_date, ref, action, price, lots, min_lots):
        self.umnem = umnem
        self.gmnem = gmnem
        self.cmnem = cmnem
        self.settl_day = iso_to_jd(settl_date)
        self.ref = ref
        self.action = action
        self.price = price
        self.lots = lots
        self.min_lots = min_lots
    def __call__(self, clnt):
        urec = get_arec_mnem(clnt, self.umnem)
        user = clnt.accnt(urec)
        grec = get_arec_mnem(clnt, self.gmnem)
        group = clnt.accnt(grec)
        crec = get_crec_mnem(clnt, self.cmnem)
        ticks = crec.price_to_ticks(self.price)
        return clnt.place(user, group, crec, self.settl_day, self.ref,
                          self.action, ticks, self.lots, self.min_lots)

class ReviseRequest(object):
    def __init__(self, umnem, id, lots):
        self.umnem = umnem
        self.id = id
        self.lots = lots

    def __call__(self, clnt):
        urec = get_arec_mnem(clnt, self.umnem)
        user = clnt.accnt(urec)
        return clnt.revise_id(user, self.id, self.lots)

class CancelRequest(object):
    def __init__(self, umnem, *ids):
        self.umnem = umnem
        self.ids = set(ids)

    def __call__(self, clnt):
        urec = get_arec_mnem(clnt, self.umnem)
        user = clnt.accnt(urec)
        arr = []
        for id in self.ids:
            arr.append(clnt.cancel_id(user, int(id)))
        return arr

class AckTradesRequest(object):
    def __init__(self, umnem, *ids):
        self.umnem = umnem
        self.ids = set(ids)

    def __call__(self, clnt):
        urec = get_arec_mnem(clnt, self.umnem)
        user = clnt.accnt(urec)
        arr = []
        for id in self.ids:
            arr.append(clnt.ack_trade(user, int(id)))
        return arr

def widths(keys, recs):
    ws = {key: len(key) for key in keys}
    for rec in recs:
        for key in keys:
            ws[key] = max(len(str(rec[key])), ws[key])
    return ws

def make_table(specs):

    pairs = [(spec[0], spec[1:]) for spec in specs]
    keys = [pair[1] for pair in pairs]

    head_fmt = '|{:<{' + '}}|{:<{'.join(keys) + '}}|'
    sep_fmt = '|{0:-<{' + '}}+{0:-<{'.join(keys) + '}}|'
    rec_fmt = '|' + '|'.join(['{0[' + pair[1] + ']:' + pair[0] + '{' + pair[1] + '}}'
                              for pair in pairs]) + '|'

    def fn(recs):
        ws = widths(keys, recs)
        print(head_fmt.format(*keys, **ws))
        print(sep_fmt.format('', **ws))
        for rec in recs:
            print(rec_fmt.format(rec, **ws))

    return fn

print_accnts = make_table([
    '<mnem',
    '<display',
    '<email'])

print_contrs = make_table([
    '<mnem',
    '<display',
    '<asset_type',
    '<asset',
    '<ccy',
    '>tick_numer',
    '>tick_denom',
    '>lot_numer',
    '>lot_denom',
    '>pip_dp',
    '>min_lots',
    '>max_lots'])

print_users = make_table([
    '<uid',
    '<gid'])

print_groups = make_table([
    '<uid',
    '<gid'])

print_orders = make_table([
    '<id',
    '<gmnem',
    '<cmnem',
    '<settl_date',
    '<state',
    '<action',
    '>price',
    '>lots',
    '>resd',
    '>exc',
    '>last_price',
    '>last_lots'])

print_trades = make_table([
    '<id',
    '<order',
    '<gmnem',
    '<cmnem',
    '<settl_date',
    '<state',
    '<action',
    '>price',
    '>lots',
    '>resd',
    '>exc',
    '>last_price',
    '>last_lots',
    '<role',
    '<cpty'])

print_posns = make_table([
    '<cmnem',
    '<settl_date',
    '>buy_price',
    '>buy_lots',
    '>sell_price',
    '>sell_lots'])

print_levels = make_table([
    '<cmnem',
    '<settl_date',
    '>level',
    '>bid_price',
    '>bid_lots',
    '>bid_count',
    '>offer_price',
    '>offer_lots',
    '>offer_count'])

print_views = make_table([
    '<cmnem',
    '<settl_date',
    '>level',
    '>bid_price',
    '>bid_lots',
    '>bid_count',
    '>offer_price',
    '>offer_lots',
    '>offer_count'])

print_env = make_table([
    '<key',
    '<value'])

class AsyncClnt(object):
    def __init__(self):
        uuid = uuid1()
        log_notice('uuid: {0}'.format(uuid))
        self.env = {}
        self.ctx = ZmqCtx()
        self.thread = Thread(target = worker, args = (self.ctx, uuid))
        self.thread.start()
        self.async = Async(self.ctx, uuid)
        self.is_closed = False

    def close(self):
        if not self.is_closed:
            self.async.sendAndRecv(CloseRequest())
            log_notice('joining')
            self.thread.join()
            self.is_closed = True

    def accnts(self, *mnems):
        print_accnts(self.async.sendAndRecv(AccntsRequest(*mnems)))

    def contrs(self, *mnems):
        print_contrs(self.async.sendAndRecv(ContrsRequest(*mnems)))

    def logon(self):
        umnem = self.env['user']
        self.async.sendAndRecv(LogonRequest(umnem))

    def logoff(self):
        umnem = self.env['user']
        self.async.sendAndRecv(LogoffRequest(umnem))

    def users(self):
        umnem = self.env['user']
        print_users(self.async.sendAndRecv(UsersRequest(umnem)))

    def groups(self):
        umnem = self.env['user']
        print_groups(self.async.sendAndRecv(GroupsRequest(umnem)))

    def orders(self):
        umnem = self.env['user']
        print_orders(self.async.sendAndRecv(OrdersRequest(umnem)))

    def trades(self):
        umnem = self.env['user']
        print_trades(self.async.sendAndRecv(TradesRequest(umnem)))

    def posns(self):
        gmnem = self.env['group']
        print_posns(self.async.sendAndRecv(PosnsRequest(gmnem)))

    def levels(self):
        cmnem = self.env['contr']
        settl_date = int(self.env['settl_date'])
        print_levels(self.async.sendAndRecv(LevelsRequest(cmnem, settl_date)))

    def views(self):
        print_views(self.async.sendAndRecv(ViewsRequest([], [])))

    def buy(self, lots, price):
        umnem = self.env['user']
        gmnem = self.env['group']
        cmnem = self.env['contr']
        settl_date = int(self.env['settl_date'])
        print(self.async.sendAndRecv(PlaceRequest(umnem, gmnem, cmnem, settl_date, '',
                                                  ACTION_BUY, float(price), int(lots), 0)))

    def sell(self, lots, price):
        umnem = self.env['user']
        gmnem = self.env['group']
        cmnem = self.env['contr']
        settl_date = int(self.env['settl_date'])
        print(self.async.sendAndRecv(PlaceRequest(umnem, gmnem, cmnem, settl_date, '',
                                                  ACTION_SELL, float(price), int(lots), 0)))

    def revise(self, id, lots):
        umnem = self.env['user']
        print(self.async.sendAndRecv(ReviseRequest(umnem, id, lots)))

    def cancel(self, *ids):
        umnem = self.env['user']
        print(self.async.sendAndRecv(CancelRequest(umnem, *ids)))

    def ack_trades(self, *ids):
        umnem = self.env['user']
        print(self.async.sendAndRecv(AckTradesRequest(umnem, *ids)))

    def echo(self, *args):
        log_notice('echo: ' + ','.join(args))

    def penv(self):
        print_env([{'key': k, 'value': v} for k, v in self.env.iteritems()])

    def set(self, name, value):
        self.env[name] = value

    def unset(self, name):
        del self.env[name]

    def quit(self):
        self.close()

@contextmanager
def async_clnt():
    ac = AsyncClnt()
    try:
        yield ac
    finally:
        log_notice('closing')
        ac.close()

if __name__ == '__main__':
    try:
        lex = shlex.shlex(sys.stdin)
        lex.wordchars = 'abcdfeghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.'
        home = os.environ['HOME']
        rcfile = os.path.join(home, '.dbr_clirc')
        if os.path.isfile(rcfile):
            lex.push_source(open(rcfile, 'r'), rcfile)
        with async_clnt() as ac:
            parse(lex, ac)
        log_notice('exiting')
    except KeyboardInterrupt as e:
        log_warn('interrupted')
    except Error as e:
        log_error('error: ' + str(e))
