#!/usr/bin/env python2

# The Restful Matching-Engine.
# Copyright (C) 2013, 2016 Swirly Cloud Limited.
#
# This program is free software; you can redistribute it and/or modify it under the terms of the
# GNU General Public License as published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program; if
# not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

from cmd import Cmd
from collections import Counter

import httplib
import json
import os
import shlex

def columnLens(rows):
  lens = Counter()
  for row in rows:
    for k, v in row.iteritems():
      k += 'Len'
      lens[k] = max(len(str(v)), lens[k])
  return lens

def header(*cols):
  return dict(zip(cols, cols))

def printTable(cols, rows, fmt):
  rows.insert(0, header(*cols))
  lens = columnLens(rows)
  for row in rows:
    row.update(lens)
    print fmt.format(**row);

class Response(object):

  def __init__(self, resp):
    self.status = resp.status
    self.reason = resp.reason
    self.content = json.load(resp)

  def __str__(self):
    return ('Response(status={},reason="{}",content="{}")'
            .format(self.status, self.reason, self.content))

class Shell(Cmd):

  def __init__(self, host, port):
    Cmd.__init__(self)
    self.conn = httplib.HTTPConnection(host, port)
    self.env = {}
    if 'SWIRLY_ACCNT' in os.environ:
      self.env['ACCNT'] = os.environ['SWIRLY_ACCNT']

  def __enter__(self):
    return self

  def __exit__(self, extype, exval, bt):
    self.close()

  def close(self):
    self.conn.close()

  def send(self, method, uri, **kwargs):
    content = ''
    if kwargs is not None:
      content = json.dumps(kwargs)
    conn = self.conn
    conn.putrequest(method, uri)
    conn.putheader('Accept', 'application/json')
    if 'ACCNT' in self.env:
      conn.putheader('Swirly-Accnt', self.env['ACCNT'])
    conn.putheader('Content-Length', len(content))
    conn.putheader('Content-Type', 'application/json')
    conn.endheaders()
    conn.send(content)
    return Response(conn.getresponse())

  def do_quit(self, args):
    """Usage: quit"""
    raise SystemExit

  def do_env(self, args):
    """Usage: env"""
    cols = [
      'name',
      'value'
    ]
    rows = [{'name': k, 'value': v} for k, v in self.env.iteritems()]
    fmt = (
      '|{name:<{nameLen}}'
      '|{value:<{valueLen}}'
      '|'
    )
    printTable(cols, rows, fmt)

  def do_set(self, args):
    """Usage: set <name> <value>"""
    try:
      name, value = shlex.split(args)
      self.env[name.upper()] = value
    except Exception as e:
      print "error: {}: {}".format(type(e).__name__, e)

  def do_unset(self, args):
    """Usage: unset <name>"""
    try:
      name, = shlex.split(args)
      del self.env[name.upper()]
    except Exception as e:
      print "error: {}: {}".format(type(e).__name__, e)

  def do_asset(self, args):
    """Usage: asset"""
    resp = self.send('GET', '/rec/asset')
    cols = [
      'mnem',
      'display',
      'type'
    ]
    rows = resp.content
    fmt = (
      '|{mnem:<{mnemLen}}'
      '|{display:<{displayLen}}'
      '|{type:<{typeLen}}'
      '|'
    )
    printTable(cols, rows, fmt)

  def do_contr(self, args):
    """Usage: contr"""
    resp = self.send('GET', '/rec/contr')
    cols = [
      'mnem',
      'display',
      'asset',
      'ccy',
      'lotNumer',
      'lotDenom',
      'tickNumer',
      'tickDenom',
      'pipDp',
      'minLots',
      'maxLots'
    ]
    rows = resp.content
    fmt = (
      '|{mnem:<{mnemLen}}'
      '|{display:<{displayLen}}'
      '|{asset:<{assetLen}}'
      '|{ccy:<{ccyLen}}'
      '|{lotNumer:>{lotNumerLen}}'
      '|{lotDenom:>{lotDenomLen}}'
      '|{tickNumer:>{tickNumerLen}}'
      '|{tickDenom:>{tickDenomLen}}'
      '|{pipDp:>{pipDpLen}}'
      '|{minLots:>{minLotsLen}}'
      '|{maxLots:>{maxLotsLen}}'
      '|'
    )
    printTable(cols, rows, fmt)

  def do_market(self, args):
    """Usage: market"""
    resp = self.send('GET', '/rec/market')
    cols = [
      'mnem',
      'display',
      'contr',
      'settlDate',
      'expiryDate',
      'state'
    ]
    rows = resp.content
    fmt = (
      '|{mnem:<{mnemLen}}'
      '|{display:<{displayLen}}'
      '|{contr:<{contrLen}}'
      '|{settlDate:<{settlDateLen}}'
      '|{expiryDate:<{expiryDateLen}}'
      '|{state:>{stateLen}}'
      '|'
    )
    printTable(cols, rows, fmt)

  def do_trader(self, args):
    """Usage: trader"""
    resp = self.send('GET', '/rec/trader')
    cols = [
      'mnem',
      'display',
      'email'
    ]
    rows = resp.content
    fmt = (
      '|{mnem:<{mnemLen}}'
      '|{display:<{displayLen}}'
      '|{email:<{emailLen}}'
      '|'
    )
    printTable(cols, rows, fmt)

  def do_order(self, args):
    """Usage: order"""
    resp = self.send('GET', '/sess/order')
    cols = [
      'trader',
      'market',
      'contr',
      'settlDate',
      'id',
      'ref',
      'state',
      'side',
      'lots',
      'ticks',
      'resd',
      'exec',
      'cost',
      'lastLots',
      'lastTicks',
      'minLots',
      'created',
      'modified'
    ]
    rows = resp.content
    fmt = (
      '|{trader:<{traderLen}}'
      '|{market:<{marketLen}}'
      '|{contr:<{contrLen}}'
      '|{settlDate:<{settlDateLen}}'
      '|{id:<{idLen}}'
      '|{ref:<{refLen}}'
      '|{state:<{stateLen}}'
      '|{side:<{sideLen}}'
      '|{lots:<{lotsLen}}'
      '|{ticks:<{ticksLen}}'
      '|{resd:<{resdLen}}'
      '|{exec:<{execLen}}'
      '|{cost:<{costLen}}'
      '|{lastLots:<{lastLotsLen}}'
      '|{lastTicks:<{lastTicksLen}}'
      '|{minLots:<{minLotsLen}}'
      '|{created:<{createdLen}}'
      '|{modified:<{modifiedLen}}'
      '|'
    )
    printTable(cols, rows, fmt)

  def do_view(self, args):
    """Usage: view"""
    resp = self.send('GET', '/view')
    cols = [
      'market',
      'contr',
      'settlDate',
      'lastLots',
      'lastTicks',
      'lastTime',
      'bidTicks',
      'bidResd',
      'bidCount',
      'offerTicks',
      'offerResd',
      'offerCount'
    ]
    rows = resp.content
    fn = lambda x: x[0] if isinstance(x, list) else x
    rows = [{k: fn(v) for k, v in row.iteritems()} for row in rows]
    fmt = (
      '|{market:<{marketLen}}'
      '|{contr:<{contrLen}}'
      '|{settlDate:<{settlDateLen}}'
      '|{lastLots:>{lastLotsLen}}'
      '|{lastTicks:>{lastTicksLen}}'
      '|{lastTime:<{lastTimeLen}}'
      '|{bidTicks:>{bidTicksLen}}'
      '|{bidResd:>{bidResdLen}}'
      '|{bidCount:>{bidCountLen}}'
      '|{offerTicks:>{offerTicksLen}}'
      '|{offerResd:>{offerResdLen}}'
      '|{offerCount:>{offerCountLen}}'
      '|'
    )
    printTable(cols, rows, fmt)

  def do_buy(self, args):
    """Usage: buy <market> <lots> <ticks>"""
    try:
      market, lots, ticks = shlex.split(args)
      resp = self.send('POST', '/sess/order/' + market,
                       side = 'BUY',
                       lots = int(lots),
                       ticks = int(ticks))
      row = resp.content
      print row
    except Exception as e:
      print "error: {}: {}".format(type(e).__name__, e)

  def do_sell(self, args):
    """Usage: sell <market> <lots> <ticks>"""
    try:
      market, lots, ticks = shlex.split(args)
      resp = self.send('POST', '/sess/order/' + market,
                       side = 'SELL',
                       lots = int(lots),
                       ticks = int(ticks))
      row = resp.content
      print row
    except Exception as e:
      print "error: {}: {}".format(type(e).__name__, e)

if __name__ == '__main__':
  with Shell('localhost', 8080) as shell:
    shell.prompt = '> '
    shell.cmdloop('Swirly Shell')
